# Introduction
## Achievement Goals
- 자료구조가 무엇인지 설명
- Stack, Queue, Tree, Graph 자료구조에 대해 이해
  - 알고리즘 문제에서 Stack, Queue 자료구조를 배열로 대체하여 흉내낼 수 있다.
  - 각 자료구조의 개념과 구조를 파악하고 목적을 이해
  - 알고리즘 문제의 각 상황에 맞는 자료구조를 떠올릴 수 있다.
- 트리 및 그래프의 탐색 기법에 대해 이해
  - Binary Search Tree를 이해
  - BFS와 DFS의 개념을 이해하고 알고리즘 문제에서 사용
- 자료구조를 활용하여 알고리즘 문제에 접근 가능

## Intro to Data Structure

⭕ 자료구조?
 여러 데이터들의 묶음을 저장하고, 사용하는 방법을 정의한 것
⭕ data?
문자, 숫자, 소리, 그림, 영상 등 실생활을 구성하고 있는 모든 값
+++
데이터만으로는 정보 활용 불가능
그러므로 분석 및 정리해서 활용해야만 의미 있음

#### 자주 등장 하는 자료 구조 Number 4
> Stack, Queue, Tree, Graph

자료구조 === 특정 상황에 놓인 문제를 해결하는데에 특화
So, 많은 자료구조를 알아두면, 어떠한 상황이 닥쳤을 때 적합한 자료구조를 빠르고 정확하게 적용하여 문제 해결 가능


### Sprint Roadmap

=핵심=
- 각 자료구조가 가진 특징을 학습
- 각 자료구조를 사용하기 적합한 상황을 이해
- 다른 자료구조와의 차이점을 이해하기 위해 자료구조 내부를 직접 구현
- 자료구조를 구현하며, 자료구조의 동작원리를 이해

1. class 키워드로 자료구조의 데이터 타입 정의
2. 자료 구조를 활용 알고리즘 문제 풀이


# Stack/Queue
## Stack
`쌓다`,`쌓이다`,`포개지다`
=> 데이터를 순서대로 쌓는 자료 구조
=> 입력과 출력이 하나의 방향으로 이루어지는 제한적 접근
=> 이런 자료 구조의 정책을 LIFO(Last In First Out) 혹은 FILO(First In Last Out) 이라고 부름

예)
브라우저의 뒤로가기, 앞으로 가기 기능

## Queue
`줄을 서서 기다리다`,`대기 행렬`
=> 먼저 들어간 데이터가 먼저 나옴
=> FIFO(First In First Out) 혹은 LILO(Last In Last Out) 

예)
프린터(들어온 순서대로 인쇄)

컴퓨터 장치들 사이에서 데이터를 주고 받을 때 장치 사이에 속도 또는 시간 차이를 극복하기 위해 임시 기억 장치의 자료구조로 사용
=>버퍼(Buffer)-> 버퍼링

# Graph/Tree/BST
## Graph
=> 거미줄처럼 여러개의 점들이 선으로 이어져 있는 복잡한 네트워크 망과 같은 모습
=> 여러개의 점들이 서로 복잡하게 연결되어 있는 관계를 표현
=> 직접적인 관계 : 두 점 사이를 이어주는 선이 있음
=> 간접적인 관계 : 몇 개의 점과 선에 걸쳐 이어짐
-> 정점(vertex) : 하나의 '점'
-> 간선(edge) : 하나의 '선'

예)
포털사이트 검색엔진
네비게이션

### 알아야 할 용어
- 비가중치 그래프: 추가적인 정보를 파악할 수 없는 그래프, 가중치(연결의 강도가 얼마나 되는지)가 적혀 있지 않은 그래프

- 무(방)향그래프(undirected graph): 앞간선을 표현하는 두 정점의 쌍에 순서 즉 방향이 없는 그래프

- 진입차수(in-degree) / 진출차수(out-degree): 한 정점에 진입(들어오는 간선)하고 진출(나가는 간선)하는 간선이 몇 개인지?

- 인접(adjacency): 두 정점간에 간선이 직접 이어져 있다면 이 두 정점은 인접한 정점

- 자기 루프(self loop): 정점에서 진출하는 간선이 곧바로 자기 자신에게 진입하는 경우 자기 루프를 가졌다 라고 표현. 
  다른 정점을 거치지 않는다는 것이 특징입니다.

- 사이클(cycle): 한 정점에서 출발하여 다시 해당 정점으로 돌아갈 수 있다면 사이클이 있다고 표현. 내비게이션 그래프는 서울 —> 대전 —> 부산 —> 서울 로 이동이 가능하므로, 사이클이 존재하는 그래프 입니다.

Q
- SNS에서 자료구조로 그래프를 이용한다면, 정점과 간선은 무엇이 될까요?
- SNS에서 어떤 관계일 경우 단방향 그래프가 생성될까요?
- 자기 루프와 사이클은 어떻게 다를까요?

### 그래프의 표현 방식: 인접 행렬 & 인접 리스트

#### 인접 행렬
-> 서로 다른 정점들이 인접한 상태인지를 표시한 행렬
-> 2차원 배열의 형태로 나타냄
-> 만약 A라는 정점과 B라는 정점이 이어져 있다면 1(true), 
   이어져 있지 않다면 0(false)으로 표시한 일종의 표
->  가중치 그래프라면 1 대신 관계에서 의미 있는 값을 저장

Q 인접 행렬은 언제 사용?
- 한 개의 큰 표와 같은 모습을 한 인접 행렬은 두 정점 사이에 관계가 있는지, 없는지 확인하기에 용이
   - 예를 들어, A에서 B로 진출하는 간선이 있는지 파악하기 위해선 0 번째 줄의 1 번째 열에 어떤 값이 저장되어있는지 바로 확인할 수 있음
- 가장 빠른 경로(shortest path)를 찾고자 할 때 주로 사용

#### 인접 리스트
-> 각 정점이 어떤 정점과 인접한지를 리스트의 형태로 표현
-> 각 정점마다 하나의 리스트를 가지고 있음
-> 이 리스트는 자신과 인접한 다른 정점을 담고 있음
-> 보통은 순서가 중요하지 않으나 우선 순위별로 정렬도 가능
=> 우선 순위를 따지면 다른 적합한 자료구조가 있음(ex. queue, heap

Q 인접 리스트는 언제 사용?
- 메모리를 효율적으로 사용하고 싶을 때 인접 리스트를 사용
  - 인접 행렬은 연결 가능한 모든 경우의 수를 저장하기 때문에 상대적으로 메모리를 많이 차지함


## Tree
=> 이름 그대로 나무의 형태를 뒤집은 모양을 가지고 있음
=> 단방향 그래프의 한 구조로, 하나의 루트(root)로부터 가지가 뻗은 형태
=> 데이터가 바로 아래에 있는 하나 이상의 데이터에 단방향으로 연결된 계층적 자료구조
=>  하나의 데이터 뒤에 여러 개의 데이터가 존재할 수 있는 비선형 구조
=> 계층적 표현, 아래로만 뻗어나가기에 사이클 없음
=> 깊이,높이,레벨 측정 가능

### 알아야 할 용어

- 노드(Node) : 트리 구조를 이루는 모든 개별 데이터
- 루트(Root) : 트리 구조의 시작점이 되는 노드
- 부모 노드(Parent node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 가까운 노드
- 자식 노드(Child node) : 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 먼 노드
- 리프(Leaf) : 트리 구조의 끝지점이고, 자식 노드가 없는 노드

#### 깊이(depth)
루트로부터 하위 계층의 특정 노드까지의 깊이(depth)

#### 레벨(Level)
같은 깊이를 가지고 있는 노드를 묶어서 레벨(level)
형제 노드(sibling Node) : 같은 레벨에 나란히 있는 노드

#### 높이(Height)
리프 노드를 기준으로 루트까지의 높이(height)
각 리프 노드의 높이를 0으로 올라갈수록 +1

#### 서브 트리(Sub tree)
큰 트리의 내부에, 트리 구조를 갖춘 작은 트리

예)
컴퓨터의 디렉토리 구조
월드컵 토너먼트 대진표
가계도

## Binary Search Tree

이진 트리(binary tree)
=> 자식 노드가 최대 두 개인 노드들로 구성된 트리

자료의 삽입, 삭제 방법에 따라 
- 정 이진 트리(Full binary tree)
- 완전 이진 트리(Complete binary tree)
- 포화 이진 트리(Perfect binary tree)

|종류|영어|설명|
|-|-|-|
|정 이진 트리|ull binary tree|각 노드가 0 개 혹은 2 개의 자식 노드|
|완전 이진 트리|Complete binary tree|정 이진 트리이면서 완전 이진 트리, 모든 리프 노드의 레벨이 동일하고, 모든 레벨이 가득 채워져 있음|
|포화 이진 트리|Perfect binary tree|마지막 레벨을 제외한 모든 노드가 가득 차 있음,마지막 레벨의 노드는 전부 차 있지 않아도 되지만 왼쪽이 채워져야함|

이진 탐색 트리(Binary Search Tree)
=> 모든 왼쪽 자식의 값이 루트나 부모보다 작고, 모든 오른쪽 자식의 값이 루트나 부모보다 큰 값을 가지는 특징

이진 탐색 트리는 균형 잡힌 트리가 아닐 때, 입력되는 값의 순서에 따라 한쪽으로 노드들이 몰리게 될 수 있음

문제점 => 균형이 잡히지 않은 트리는 탐색하는 데 시간이 더 걸리는 경우도 있음
=> 해결법 : 삽입과 삭제마다 트리의 구조를 재조정하는 과정을 거치는 알고리즘을 추가할 수 있음

# Graph,Tree Search Algorithm

## Tree traversal(트리 순회)


